package org.sasanlabs.service.vulnerability.fileupload;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.util.ReflectionTestUtils.setField;

import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.utils.Constants;
import org.springframework.http.ResponseEntity;
import org.springframework.mock.web.MockMultipartFile;

class UnrestrictedFileUploadTest {

    private UnrestrictedFileUpload fileUpload;

    @TempDir Path tempRoot;

    @TempDir Path tempContentDispositionRoot;

    @BeforeEach
    void setUp() throws IOException, URISyntaxException {
        fileUpload = new UnrestrictedFileUpload();
        setField(fileUpload, "root", tempRoot);
        setField(fileUpload, "contentDispositionRoot", tempContentDispositionRoot);
    }

    @Test
    void test_getVulnerablePayloadLevel1() throws Exception {
        MockMultipartFile file =
                new MockMultipartFile("file", "test.html", "text/html", "content".getBytes());
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                fileUpload.getVulnerablePayloadLevel1(file);

        assertThat(response.getBody().getIsValid()).isTrue();
        assertThat(tempRoot.resolve("test.html")).exists();
    }

    @Test
    void test_getVulnerablePayloadLevel2() throws Exception {
        MockMultipartFile file =
                new MockMultipartFile("file", "image.png", "image/png", "content".getBytes());
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                fileUpload.getVulnerablePayloadLevel2(file);

        assertThat(response.getBody().getIsValid()).isTrue();
        try (Stream<Path> files = Files.list(tempRoot)) {
            assertThat(files.count()).isGreaterThan(0);
        }
    }

    @Test
    void test_getVulnerablePayloadLevel3() throws Exception {
        MockMultipartFile file =
                new MockMultipartFile("file", "attack.html", "text/html", "content".getBytes());
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                fileUpload.getVulnerablePayloadLevel3(file);

        assertThat(response.getBody().getIsValid()).isFalse();
    }

    @Test
    void test_getVulnerablePayloadLevel4() throws Exception {
        MockMultipartFile file =
                new MockMultipartFile("file", "attack.htm", "text/html", "content".getBytes());
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                fileUpload.getVulnerablePayloadLevel4(file);

        assertThat(response.getBody().getIsValid()).isFalse();
    }

    @Test
    void test_getVulnerablePayloadLevel5() throws Exception {
        MockMultipartFile file =
                new MockMultipartFile("file", "attack.HTM", "text/html", "content".getBytes());
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                fileUpload.getVulnerablePayloadLevel5(file);

        assertThat(response.getBody().getIsValid()).isFalse();
    }

    @Test
    void test_getVulnerablePayloadLevel6() throws Exception {
        MockMultipartFile file =
                new MockMultipartFile(
                        "file", "malicious.png.html", "text/html", "content".getBytes());
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                fileUpload.getVulnerablePayloadLevel6(file);

        assertThat(response.getBody().getIsValid()).isTrue();
    }

    @Test
    void test_getVulnerablePayloadLevel7() throws Exception {
        String fileName = "shell.php" + Constants.NULL_BYTE_CHARACTER + ".png";
        MockMultipartFile file =
                new MockMultipartFile("file", fileName, "text/plain", "content".getBytes());

        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                fileUpload.getVulnerablePayloadLevel7(file);

        assertThat(response.getBody().getIsValid())
                .withFailMessage("Level 7 validation should pass for null byte suffix")
                .isTrue();

        try (Stream<Path> files = Files.list(tempRoot)) {
            List<String> fileNames =
                    files.map(p -> p.getFileName().toString()).collect(Collectors.toList());

            assertThat(fileNames)
                    .withFailMessage("Expected truncated .php file, but found: %s", fileNames)
                    .anyMatch(name -> name.contains("shell.php") && !name.endsWith(".png"));
        }
    }

    @Test
    void test_getVulnerablePayloadLevel7_WithoutNullByte() throws Exception {
        // 1. Arrange: Use a filename WITHOUT a null byte
        String fileName = "normal_image.png";
        MockMultipartFile file =
                new MockMultipartFile("file", fileName, "image/png", "dummy content".getBytes());

        // 2. Act
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                fileUpload.getVulnerablePayloadLevel7(file);

        // 3. Assert Response
        assertThat(response.getBody().getIsValid())
                .withFailMessage("Validation should pass for a normal .png file")
                .isTrue();

        // 4. Assert File System
        try (Stream<Path> files = Files.list(tempRoot)) {
            List<String> fileNames =
                    files.map(p -> p.getFileName().toString()).collect(Collectors.toList());

            // Verify that the file was saved ending with the original name (normal_image.png)
            // and includes the random prefix assigned by the controller
            assertThat(fileNames)
                    .withFailMessage(
                            "Expected file to be saved with original name, but found: %s",
                            fileNames)
                    .anyMatch(name -> name.endsWith("_" + fileName));
        }
    }

    @Test
    void test_getVulnerablePayloadLevel8() throws Exception {
        MockMultipartFile file =
                new MockMultipartFile("file", "traversal.txt", "text/plain", "content".getBytes());
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                fileUpload.getVulnerablePayloadLevel8(file);

        assertThat(response.getBody().getIsValid()).isTrue();
        assertThat(tempContentDispositionRoot.resolve("traversal.txt")).exists();
    }

    @Test
    void test_getVulnerablePayloadLevel9() throws Exception {
        MockMultipartFile file =
                new MockMultipartFile("file", "dos.txt", "text/plain", new byte[1024]);
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                fileUpload.getVulnerablePayloadLevel9(file);

        assertThat(response.getBody().getIsValid()).isTrue();
    }

    @Test
    void test_getVulnerablePayloadLevel10() throws Exception {
        MockMultipartFile malicious =
                new MockMultipartFile("file", "test.png.php", "text/plain", "content".getBytes());
        ResponseEntity<GenericVulnerabilityResponseBean<String>> response =
                fileUpload.getVulnerablePayloadLevel10(malicious);

        assertThat(response.getBody().getIsValid()).isFalse();
    }
}
