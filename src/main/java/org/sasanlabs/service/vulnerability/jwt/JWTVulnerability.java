package org.sasanlabs.service.vulnerability.jwt;

import static org.sasanlabs.service.vulnerability.jwt.bean.JWTUtils.GENERIC_BASE64_ENCODED_PAYLOAD;

import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.KeyUse;
import com.nimbusds.jose.jwk.RSAKey;
import java.io.UnsupportedEncodingException;
import java.security.KeyPair;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.json.JSONObject;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.RequestParameterLocation;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.exception.ServiceApplicationException;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.service.vulnerability.jwt.bean.JWTUtils;
import org.sasanlabs.service.vulnerability.jwt.keys.JWTAlgorithmKMS;
import org.sasanlabs.service.vulnerability.jwt.keys.KeyStrength;
import org.sasanlabs.service.vulnerability.jwt.keys.SymmetricAlgorithmKey;
import org.sasanlabs.vulnerability.types.VulnerabilitySubType;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.http.HttpStatus;
import org.springframework.http.RequestEntity;
import org.springframework.http.ResponseEntity;
import org.springframework.util.CollectionUtils;
import org.springframework.util.MultiValueMap;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * JWT client and server side implementation issues and remediations. Server side issues like: 1.
 * Weak HMAC key 2. none algorithm attack 3. Weak Hash algorithm 4. tweak Algorithm and Key.
 *
 * <p>Client side issues like: 1. Storing jwt in local storage/session storage hence if attacked
 * with XSS can be quite dangerous. 2. Storing jwt in cookies without httponly/secure flags or
 * cookie prefixes.
 *
 * <p>{@link //https://github.com/SasanLabs/JWTExtension/blob/master/BrainStorming.md}
 *
 * @author KSASAN preetkaran20@gmail.com
 */
@VulnerableAppRestController(
        descriptionLabel = "JWT_INJECTION_VULNERABILITY",
        value = "JWTVulnerability",
        type = {VulnerabilityType.VULNERABLE_JWT_IMPLMENTATION})
public class JWTVulnerability {

    private IJWTTokenGenerator libBasedJWTGenerator;
    private IJWTValidator jwtValidator;

    private static final transient Logger LOGGER = LogManager.getLogger(JWTVulnerability.class);

    private static final String JWT = "JWT";
    private static final String JWT_COOKIE_KEY = JWT + "=";

    /**
     * Constant JWT's. These are precomputed because we have to return Sample Values for helping
     * scanners to know about the format of the input so that they can attack accordingly. we can
     * precompute these tokens because content of token is static and also keys are static.
     */
    // Constant JWT HS256 Signed with High Strength Key.
    private static final String PRECOMPUTED_JWT_HS256_HIGH_STRENGTH =
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.MZiW2KkIRI6GhKsu16Me7-3IpS4nBw1W47CW67QAqS0";
    // Constant JWT HS256 Signed with LOW Strength Key.
    private static final String PRECOMPUTED_JWT_HS256_LOW_STRENGTH =
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.kXSdJhhUKTJemgs8O0rfIJmUaxoSIDdClL_OPmaC7Eo";
    // Constant JWT RS256 Signed
    private static final String PRECOMPUTED_JWT_RS256 =
            "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0"
                    + ".k5_ifQHwxXrjjg0CNExhTzkPLOk88UA3C3KlQLc2AdGQl4kXGOy46f2DZsJGopy_cT1DSVl0HfzkDhm6RTutv7fGdr7tjqwWBPu-oIBQQytVejDW4WyyuozjsWrvr"
                    + "OHGMFyaO7FHEufGLRJ0ZAZ0SC4R-IAor8ggWhKaRqanKTZfTBQZWaGs3js5B7xcr2LUBRMNdGFJEJHdbMa3LtcmU-plmltesJpUcmoorFNjmt5li9xrpBSSf5-5ruj"
                    + "P1lp5lEqwrRTCl07NQVXlvh6plZYR5-3WJ2IFSBEqkz9ztUNCSTHOxVF_5LG05NxhwkVsxUvcvhGLWsMtiA8yg2-P-g";
    // Constant JWT RS256 signed with JWK
    private static final String PRECOMPUTED_JWT_RS256_WITH_JWK =
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp3ayI6eyJrdHkiOiJSU0EiLCJlIjoiQVFBQiIsInVzZSI6InNpZyIsImtpZCI6IjhmYzgzYmE1LTRmNjUtNDg4ZS05Y"
                    + "jQ5LTUyZGNhOThiZTNiZiIsIm4iOiJ4dk9ncUVyUW1XNEU0dGN3QXZQdnp1WUs0RGxxMlYzaHNKcFJwQjJyeVdwa3EydnlXeVcySlBJc2FUMjFvUkhWbmxSbzZEUmpw"
                    + "ZTROd3dDb1NYUTRlVS1weXRpWG54SjdKSlNlWlVpcmIwR0NsTGMzQ3VWSDZEUzl2Z3BLcEJDMW56OHRSbkFvSDRhRDNGQVFTR3EzLU1vbm1DZ0V6X1hTOTFGeUJKS2F"
                    + "qR2pidFBka0lvYzZaWUcxRjNCTXdPQmlFbUZTY2dMYmhGMTg5MVp1aDluSUNJdmJMM3hvSkJXTHRRLTZsVmZxWVZ5TWF3RlZPSFFkV1lXbXJpeXJNY2wyak5ueEszcT"
                    + "E5UXYzcWdESTA3dUd4aFhXbWgwYTlPLUgyRHFiclR0X0M1ZFJPeXZONDhVOVI0WXlveE03OTdSejk0WHVJMUhqQlVGY1Z4RXlrX013SVEifX0.eyJzdWIiOiIxMjM0N"
                    + "TY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.rsEJeVbj1Bukf56CMWZvGHft3-lJO0e9EhrCkrzVwHBJoB8ZKR8x"
                    + "CINRtpDl327jPbTU_ouW4Dq6yCmhtrytxDsjzznUlHwKPiO7znI9oiWL98ADCJVPrlXL5VvyCk9bsJ78ADddDgTO1jYRcO6BJ2628hZZEOKBIeL0PtEwe1_1jLHEFqf"
                    + "w944gGWVmwqCf3LZPZVbVZ7icLPqRABXL7_VPId2bQcc7wNlvNB3dsQzvYD31KoCpGgcuYAoql46fTZHI5v2_QxYCJH6Sp-iep9O-iN2tlHdM6dnUIQO8MGV7GWsxeL"
                    + "UAqsStxiLGNZYz-uDYPr6-RieCTu5nM7KbaQ";

    public JWTVulnerability(IJWTTokenGenerator libBasedJWTGenerator, IJWTValidator jwtValidator) {
        this.libBasedJWTGenerator = libBasedJWTGenerator;
        this.jwtValidator = jwtValidator;
    }

    private ResponseEntity<GenericVulnerabilityResponseBean<String>> getJWTResponseBean(
            boolean isValid,
            String jwtToken,
            boolean includeToken,
            MultiValueMap<String, String> headers) {
        GenericVulnerabilityResponseBean<String> genericVulnerabilityResponseBean;
        if (includeToken) {
            genericVulnerabilityResponseBean =
                    new GenericVulnerabilityResponseBean<String>(jwtToken, isValid);
        } else {
            genericVulnerabilityResponseBean =
                    new GenericVulnerabilityResponseBean<String>(null, isValid);
        }
        if (!isValid) {
            ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                    new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                            genericVulnerabilityResponseBean, headers, HttpStatus.UNAUTHORIZED);
            return responseEntity;
        }
        return new ResponseEntity<GenericVulnerabilityResponseBean<String>>(
                genericVulnerabilityResponseBean, headers, HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "JWT_URL_EXPOSING_SECURE_INFORMATION")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            descriptionLabel = "URL_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_1/JWT_Level1",
            parameterName = JWT)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure(@RequestParam Map<String, String> queryParams)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.info(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        String token = queryParams.get(JWT);
        if (token != null) {
            boolean isValid =
                    jwtValidator.customHMACValidator(
                            token,
                            JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                            JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
            return this.getJWTResponseBean(isValid, token, !isValid, null);
        } else {
            token =
                    libBasedJWTGenerator.getHMACSignedJWTToken(
                            JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                            JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                            JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
            return this.getJWTResponseBean(true, token, true, null);
        }
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_CONTAINING_JWT_TOKEN_SECURITY_ATTRIBUTES_MISSING")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure2CookieBased(
                    RequestEntity<String> requestEntity,
                    @RequestParam Map<String, String> queryParams)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.info(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = requestEntity.getHeaders().get("cookie");
        boolean isFetch = Boolean.valueOf(queryParams.get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    Map<String, List<String>> headers = new HashMap<>();
                    headers.put("Set-Cookie", Arrays.asList(token));
                    ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                            this.getJWTResponseBean(
                                    isValid,
                                    token,
                                    !isValid,
                                    CollectionUtils.toMultiValueMap(headers));
                    return responseEntity;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token));
        ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                this.getJWTResponseBean(
                        true, token, true, CollectionUtils.toMultiValueMap(headers));
        return responseEntity;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure3CookieBased(
                    RequestEntity<String> requestEntity,
                    @RequestParam Map<String, String> queryParams)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.info(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = requestEntity.getHeaders().get("cookie");
        boolean isFetch = Boolean.valueOf(queryParams.get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    Map<String, List<String>> headers = new HashMap<>();
                    headers.put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                            this.getJWTResponseBean(
                                    isValid,
                                    token,
                                    !isValid,
                                    CollectionUtils.toMultiValueMap(headers));
                    return responseEntity;
                }
            }
        }
        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                this.getJWTResponseBean(
                        true, token, true, CollectionUtils.toMultiValueMap(headers));
        return responseEntity;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.INSECURE_CONFIGURATION_JWT,
            description = "COOKIE_BASED_LOW_KEY_STRENGTH_JWT_VULNERABILITY")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure4CookieBased(
                    RequestEntity<String> requestEntity,
                    @RequestParam Map<String, String> queryParams)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.LOW);
        LOGGER.info(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = requestEntity.getHeaders().get("cookie");
        boolean isFetch = Boolean.valueOf(queryParams.get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    Map<String, List<String>> headers = new HashMap<>();
                    headers.put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                            this.getJWTResponseBean(
                                    isValid,
                                    token,
                                    !isValid,
                                    CollectionUtils.toMultiValueMap(headers));
                    return responseEntity;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                this.getJWTResponseBean(
                        true, token, true, CollectionUtils.toMultiValueMap(headers));
        return responseEntity;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = {
                VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
                VulnerabilitySubType.NULL_BYTE
            },
            description = "COOKIE_BASED_NULL_BYTE_JWT_VULNERABILITY")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure5CookieBased(
                    RequestEntity<String> requestEntity,
                    @RequestParam Map<String, String> queryParams)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.info(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = requestEntity.getHeaders().get("cookie");
        boolean isFetch = Boolean.valueOf(queryParams.get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACNullByteVulnerableValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    Map<String, List<String>> headers = new HashMap<>();
                    headers.put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                            this.getJWTResponseBean(
                                    isValid,
                                    token,
                                    !isValid,
                                    CollectionUtils.toMultiValueMap(headers));
                    return responseEntity;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                this.getJWTResponseBean(
                        true, token, true, CollectionUtils.toMultiValueMap(headers));
        return responseEntity;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_NONE_ALGORITHM_JWT_VULNERABILITY",
            payload = "NONE_ALGORITHM_ATTACK_CURL_PAYLOAD")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_6,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure6CookieBased(
                    RequestEntity<String> requestEntity,
                    @RequestParam Map<String, String> queryParams)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.info(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = requestEntity.getHeaders().get("cookie");
        boolean isFetch = Boolean.valueOf(queryParams.get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACNoneAlgorithmVulnerableValidator(
                                    cookieKeyValue[1],
                                    JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    Map<String, List<String>> headers = new HashMap<>();
                    headers.put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                            this.getJWTResponseBean(
                                    isValid,
                                    token,
                                    !isValid,
                                    CollectionUtils.toMultiValueMap(headers));
                    return responseEntity;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                this.getJWTResponseBean(
                        true, token, true, CollectionUtils.toMultiValueMap(headers));
        return responseEntity;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_KEY_CONFUSION_JWT_VULNERABILITY")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_7,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure7CookieBased(
                    RequestEntity<String> requestEntity,
                    @RequestParam Map<String, String> queryParams)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<KeyPair> asymmetricAlgorithmKeyPair =
                jwtAlgorithmKMS.getAsymmetricAlgorithmKey("RS256");
        LOGGER.info(
                asymmetricAlgorithmKeyPair.isPresent() + " " + asymmetricAlgorithmKeyPair.get());
        List<String> tokens = requestEntity.getHeaders().get("cookie");
        boolean isFetch = Boolean.valueOf(queryParams.get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.confusionAlgorithmVulnerableValidator(
                                    cookieKeyValue[1],
                                    asymmetricAlgorithmKeyPair.get().getPublic());
                    Map<String, List<String>> headers = new HashMap<>();
                    headers.put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                            this.getJWTResponseBean(
                                    isValid,
                                    token,
                                    !isValid,
                                    CollectionUtils.toMultiValueMap(headers));

                    return responseEntity;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getJWTToken_RS256(
                        JWTUtils.RS256_TOKEN_TO_BE_SIGNED,
                        asymmetricAlgorithmKeyPair.get().getPrivate());
        Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                this.getJWTResponseBean(
                        true, token, true, CollectionUtils.toMultiValueMap(headers));
        return responseEntity;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_FOR_JWK_HEADER_BASED_JWT_VULNERABILITY")
    // https://nvd.nist.gov/vuln/detail/CVE-2018-0114
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_8,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure8CookieBased(
                    RequestEntity<String> requestEntity,
                    @RequestParam Map<String, String> queryParams)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<KeyPair> asymmetricAlgorithmKeyPair =
                jwtAlgorithmKMS.getAsymmetricAlgorithmKey("RS256");
        LOGGER.info(
                asymmetricAlgorithmKeyPair.isPresent() + " " + asymmetricAlgorithmKeyPair.get());
        List<String> tokens = requestEntity.getHeaders().get("cookie");
        boolean isFetch = Boolean.valueOf(queryParams.get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.jwkKeyHeaderPublicKeyTrustingVulnerableValidator(
                                    cookieKeyValue[1]);
                    Map<String, List<String>> headers = new HashMap<>();
                    headers.put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                            this.getJWTResponseBean(
                                    isValid,
                                    token,
                                    !isValid,
                                    CollectionUtils.toMultiValueMap(headers));
                    return responseEntity;
                }
            }
        }

        JWK jwk =
                new RSAKey.Builder((RSAPublicKey) asymmetricAlgorithmKeyPair.get().getPublic())
                        .keyUse(KeyUse.SIGNATURE)
                        .keyID(UUID.randomUUID().toString())
                        .build();
        JSONObject header = new JSONObject();
        header.put(JWTUtils.JWT_ALGORITHM_KEY_HEADER, "RS256");
        header.put("typ", "JWT");
        header.put(JWTUtils.JSON_WEB_KEY_HEADER, new JSONObject(jwk.toJSONString()));

        String base64EncodedHeader =
                JWTUtils.getBase64UrlSafeWithoutPaddingEncodedString(header.toString());
        String token =
                libBasedJWTGenerator.getJWTToken_RS256(
                        base64EncodedHeader
                                + JWTUtils.JWT_TOKEN_PERIOD_CHARACTER
                                + GENERIC_BASE64_ENCODED_PAYLOAD,
                        asymmetricAlgorithmKeyPair.get().getPrivate());
        Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                this.getJWTResponseBean(
                        true, token, true, CollectionUtils.toMultiValueMap(headers));
        return responseEntity;
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT,
            description = "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    @AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.SERVER_SIDE_VULNERABLE_JWT,
            description = "COOKIE_BASED_EMPTY_TOKEN_JWT_VULNERABILITY")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_9,
            descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
            htmlTemplate = "LEVEL_2/JWT_Level2",
            parameterName = JWT,
            requestParameterLocation = RequestParameterLocation.COOKIE)
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure9CookieBased(
                    RequestEntity<String> requestEntity,
                    @RequestParam Map<String, String> queryParams)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        JWTAlgorithmKMS jwtAlgorithmKMS = new JWTAlgorithmKMS();
        Optional<SymmetricAlgorithmKey> symmetricAlgorithmKey =
                jwtAlgorithmKMS.getSymmetricAlgorithmKey(
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM, KeyStrength.HIGH);
        LOGGER.info(symmetricAlgorithmKey.isPresent() + " " + symmetricAlgorithmKey.get());
        List<String> tokens = requestEntity.getHeaders().get("cookie");
        boolean isFetch = Boolean.valueOf(queryParams.get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    boolean isValid =
                            jwtValidator.customHMACEmptyTokenVulnerableValidator(
                                    cookieKeyValue[1],
                                    symmetricAlgorithmKey.get().getKey(),
                                    JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
                    Map<String, List<String>> headers = new HashMap<>();
                    headers.put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                            this.getJWTResponseBean(
                                    isValid,
                                    token,
                                    !isValid,
                                    CollectionUtils.toMultiValueMap(headers));
                    return responseEntity;
                }
            }
        }

        String token =
                libBasedJWTGenerator.getHMACSignedJWTToken(
                        JWTUtils.HS256_TOKEN_TO_BE_SIGNED,
                        JWTUtils.getBytes(symmetricAlgorithmKey.get().getKey()),
                        JWTUtils.JWT_HMAC_SHA_256_ALGORITHM);
        Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                this.getJWTResponseBean(
                        true, token, true, CollectionUtils.toMultiValueMap(headers));
        return responseEntity;
    }

    // Commented for now because this is not fully developed
    // @AttackVector(
    // vulnerabilityExposed = {VulnerabilitySubType.CLIENT_SIDE_VULNERABLE_JWT},
    // description =
    // "COOKIE_WITH_HTTPONLY_WITHOUT_SECURE_FLAG_BASED_JWT_VULNERABILITY")
    // @AttackVector(
    // vulnerabilityExposed = {VulnerabilitySubType.INSECURE_CONFIGURATION_JWT,
    // VulnerabilitySubType.BLIND_SQL_INJECTION},
    // description = "COOKIE_BASED_EMPTY_TOKEN_JWT_VULNERABILITY")
    // @VulnerabilityLevel(
    // value = LevelEnum.LEVEL_10,
    // descriptionLabel = "COOKIE_CONTAINING_JWT_TOKEN",
    // htmlTemplate = "LEVEL_2/JWT_Level2",
    // parameterName = JWT,
    // requestParameterLocation = RequestParameterLocation.COOKIE,
    public ResponseEntity<GenericVulnerabilityResponseBean<String>>
            getVulnerablePayloadLevelUnsecure10CookieBased(
                    RequestEntity<String> requestEntity,
                    @RequestParam Map<String, String> queryParams)
                    throws UnsupportedEncodingException, ServiceApplicationException {
        List<String> tokens = requestEntity.getHeaders().get("cookie");
        boolean isFetch = Boolean.valueOf(queryParams.get("fetch"));
        if (!isFetch) {
            for (String token : tokens) {
                String[] cookieKeyValue = token.split(JWTUtils.BASE64_PADDING_CHARACTER_REGEX);
                if (cookieKeyValue[0].equals(JWT)) {
                    RSAPublicKey rsaPublicKey =
                            JWTUtils.getRSAPublicKeyFromProvidedPEMFilePath(
                                    this.getClass()
                                            .getClassLoader()
                                            .getResourceAsStream(
                                                    JWTUtils.KEYS_LOCATION + "public_crt.pem"));
                    boolean isValid =
                            this.jwtValidator.genericJWTTokenValidator(
                                    cookieKeyValue[1], rsaPublicKey, "RS256");
                    Map<String, List<String>> headers = new HashMap<>();
                    headers.put("Set-Cookie", Arrays.asList(token + "; httponly"));
                    ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                            this.getJWTResponseBean(
                                    isValid,
                                    token,
                                    !isValid,
                                    CollectionUtils.toMultiValueMap(headers));
                    return responseEntity;
                }
            }
        }
        RSAPrivateKey rsaPrivateKey =
                JWTUtils.getRSAPrivateKeyFromProvidedPEMFilePath(
                        this.getClass()
                                .getClassLoader()
                                .getResourceAsStream(JWTUtils.KEYS_LOCATION + "private_key.pem"));
        String token =
                libBasedJWTGenerator.getJWTToken_RS256(
                        JWTUtils.RS256_TOKEN_TO_BE_SIGNED, rsaPrivateKey);
        Map<String, List<String>> headers = new HashMap<>();
        headers.put("Set-Cookie", Arrays.asList(JWT_COOKIE_KEY + token + "; httponly"));
        ResponseEntity<GenericVulnerabilityResponseBean<String>> responseEntity =
                this.getJWTResponseBean(
                        true, token, true, CollectionUtils.toMultiValueMap(headers));
        return responseEntity;
    }
}
