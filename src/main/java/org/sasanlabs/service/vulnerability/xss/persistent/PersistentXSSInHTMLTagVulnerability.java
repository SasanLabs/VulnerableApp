package org.sasanlabs.service.vulnerability.xss.persistent;

import java.util.Map;
import java.util.function.Function;
import java.util.regex.Pattern;
import org.apache.commons.text.StringEscapeUtils;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.Variant;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.sasanlabs.vulnerability.utils.Constants;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestParam;

/** @author preetkaran20@gmail.com KSASAN */
@VulnerableAppRestController(
        descriptionLabel = "XSS_VULNERABILITY",
        value = "PersistentXSSInHTMLTagVulnerability")
public class PersistentXSSInHTMLTagVulnerability {

    private static final String PARAMETER_NAME = "comment";
    private static final Pattern IMG_INPUT_TAG_PATTERN = Pattern.compile("(<img)|(<input)+");
    private static final Pattern IMG_INPUT_TAG_CASE_INSENSITIVE_PATTERN =
            Pattern.compile("((?i)<img)|((?i)<script)+");

    private PostRepository postRepository;

    public PersistentXSSInHTMLTagVulnerability(PostRepository postRepository) {
        this.postRepository = postRepository;
    }
    /**
     * Common utility for returning the Payload provided the Level and the computation applied on
     * post's content.
     *
     * @param queryParams
     * @param level as we are storing posts per level so that they don't interfere between levels.
     * @param function to be applied on the data from DB before returning.
     * @return
     */
    private String getCommentsPayload(
            Map<String, String> queryParams, String level, Function<String, String> function) {
        if (queryParams.containsKey(PARAMETER_NAME)) {
            Post post = new Post();
            post.setLevelIdentifier(level);
            post.setContent(queryParams.get(PARAMETER_NAME));
            this.postRepository.save(post);
        }
        StringBuilder posts = new StringBuilder();
        this.postRepository
                .findByLevelIdentifier(level)
                .forEach(
                        (post) -> {
                            posts.append(
                                    "<div id=\"comments\">"
                                            + function.apply(post.getContent())
                                            + "</div>");
                        });
        return posts.toString();
    }

    /**
     * Validates if the post contains the provides pattern. This method represents some kind of
     * validator which is vulnerable to Null Bytes
     *
     * @param post
     * @param pattern
     * @return
     */
    private boolean nullByteVulnerablePatternChecker(String post, Pattern pattern) {
        boolean containsHarmfulTags = false;
        if (post.contains(Constants.NULL_BYTE_CHARACTER)) {
            containsHarmfulTags =
                    pattern.matcher(post.substring(0, post.indexOf(Constants.NULL_BYTE_CHARACTER)))
                            .find();
        } else {
            containsHarmfulTags = pattern.matcher(post).find();
        }
        return containsHarmfulTags;
    }

    // Just adding User defined input(Untrusted Data) into div tag is not secure.
    // Can be broken by various ways
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.PERSISTENT_XSS,
            description = "PERSISTENT_XSS_HTML_TAG_URL_PARAM_DIRECTLY_INJECTED_IN_DIV_TAG")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            htmlTemplate = "LEVEL_1/PersistentXSS")
    public ResponseEntity<String> getVulnerablePayloadLevel1(
            @RequestParam Map<String, String> queryParams) {
        return new ResponseEntity<String>(
                this.getCommentsPayload(queryParams, LevelConstants.LEVEL_1, post -> post),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.PERSISTENT_XSS,
            description =
                    "PERSISTENT_XSS_HTML_TAG_URL_PARAM_DIRECTLY_INJECTED_IN_DIV_TAG_REPLACING_IMG_AND_INPUT_TAG")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            htmlTemplate = "LEVEL_1/PersistentXSS")
    public ResponseEntity<String> getVulnerablePayloadLevel2(
            @RequestParam Map<String, String> queryParams) {
        return new ResponseEntity<String>(
                this.getCommentsPayload(
                        queryParams,
                        LevelConstants.LEVEL_2,
                        post -> IMG_INPUT_TAG_PATTERN.matcher(post).replaceAll("")),
                HttpStatus.OK);
    }

    // <image src=" " onerror="alert(1)" >
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.PERSISTENT_XSS,
            description =
                    "PERSISTENT_XSS_HTML_TAG_URL_PARAM_DIRECTLY_INJECTED_IN_DIV_TAG_REPLACING_IMG_AND_INPUT_TAG_CASE_INSENSITIVE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            htmlTemplate = "LEVEL_1/PersistentXSS")
    public ResponseEntity<String> getVulnerablePayloadLevel3(
            @RequestParam Map<String, String> queryParams) {
        return new ResponseEntity<String>(
                this.getCommentsPayload(
                        queryParams,
                        LevelConstants.LEVEL_3,
                        post ->
                                IMG_INPUT_TAG_CASE_INSENSITIVE_PATTERN
                                        .matcher(post)
                                        .replaceAll("")),
                HttpStatus.OK);
    }

    // NullByte
    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PERSISTENT_XSS},
            description =
                    "PERSISTENT_XSS_HTML_TAG_URL_PARAM_DIRECTLY_INJECTED_IN_DIV_TAG_REPLACING_IMG_AND_INPUT_TAG_IF_TAGS_ARE_PRESENT_BEFORE_NULL_BYTE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            htmlTemplate = "LEVEL_1/PersistentXSS")
    public ResponseEntity<String> getVulnerablePayloadLevel4(
            @RequestParam Map<String, String> queryParams) {
        Function<String, String> function =
                (post) -> {
                    boolean containsHarmfulTags =
                            this.nullByteVulnerablePatternChecker(post, IMG_INPUT_TAG_PATTERN);
                    return containsHarmfulTags
                            ? IMG_INPUT_TAG_PATTERN.matcher(post).replaceAll("")
                            : post;
                };
        return new ResponseEntity<String>(
                this.getCommentsPayload(queryParams, LevelConstants.LEVEL_4, function),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PERSISTENT_XSS},
            description =
                    "PERSISTENT_XSS_HTML_TAG_URL_PARAM_DIRECTLY_INJECTED_IN_DIV_TAG_REPLACING_IMG_AND_INPUT_TAG_CASE_INSENSITIVEIF_TAGS_ARE_PRESENT_BEFORE_NULL_BYTE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            htmlTemplate = "LEVEL_1/PersistentXSS")
    public ResponseEntity<String> getVulnerablePayloadLevel5(
            @RequestParam Map<String, String> queryParams) {
        Function<String, String> function =
                (post) -> {
                    boolean containsHarmfulTags =
                            this.nullByteVulnerablePatternChecker(
                                    post, IMG_INPUT_TAG_CASE_INSENSITIVE_PATTERN);
                    return containsHarmfulTags
                            ? IMG_INPUT_TAG_CASE_INSENSITIVE_PATTERN.matcher(post).replaceAll("")
                            : post;
                };
        return new ResponseEntity<String>(
                this.getCommentsPayload(queryParams, LevelConstants.LEVEL_5, function),
                HttpStatus.OK);
    }

    @AttackVector(
            vulnerabilityExposed = {VulnerabilityType.PERSISTENT_XSS},
            description =
                    "PERSISTENT_XSS_HTML_TAG_URL_PARAM_DIRECTLY_INJECTED_IN_DIV_TAG_AFTER_HTML_ESCAPING_POST_CONTENT_BEFORE_NULL_BYTE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_6,
            htmlTemplate = "LEVEL_1/PersistentXSS")
    public ResponseEntity<String> getVulnerablePayloadLevel6(
            @RequestParam Map<String, String> queryParams) {
        Function<String, String> function =
                (post) -> {
                    // This logic represents null byte vulnerable escapeHtml function
                    return post.contains(Constants.NULL_BYTE_CHARACTER)
                            ? StringEscapeUtils.escapeHtml4(
                                            post.substring(
                                                    0, post.indexOf(Constants.NULL_BYTE_CHARACTER)))
                                    + post.substring(post.indexOf(Constants.NULL_BYTE_CHARACTER))
                            : StringEscapeUtils.escapeHtml4(post);
                };
        return new ResponseEntity<String>(
                this.getCommentsPayload(queryParams, LevelConstants.LEVEL_6, function),
                HttpStatus.OK);
    }

    // as we are adding to div tag so we can leverage the Html Escape for taking care of XSS.
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_7,
            htmlTemplate = "LEVEL_1/PersistentXSS",
            variant = Variant.SECURE)
    public ResponseEntity<String> getVulnerablePayloadLevel7(
            @RequestParam Map<String, String> queryParams) {
        return new ResponseEntity<String>(
                this.getCommentsPayload(
                        queryParams,
                        LevelConstants.LEVEL_7,
                        post -> StringEscapeUtils.escapeHtml4(post)),
                HttpStatus.OK);
    }
    //escape html and delete all the script and img tags
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_8,
            htmlTemplate = "LEVEL_1/PersistentXSS",
            variant = Variant.SECURE)
    public ResponseEntity<String> getSecurePayloadLevel8(
            @RequestParam Map<String, String> queryParams) {
        return new ResponseEntity<>(
                this.getCommentsPayload(
                        queryParams,
                        LevelConstants.LEVEL_8,
                        post -> StringEscapeUtils.escapeHtml4(
                                post.replaceAll("(?i)<script.*?>.*?</script>", "")
                                    .replaceAll("(?i)<img.*?>", ""))),
                HttpStatus.OK);
    }
    //delete all the html tags
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_9,
            htmlTemplate = "LEVEL_1/PersistentXSS",
            variant = Variant.SECURE)
    public ResponseEntity<String> getSecurePayloadLevel9(
            @RequestParam Map<String, String> queryParams) {
        Function<String, String> function =
                (post) -> {
                    String sanitizedPost = post.replaceAll("<.*?>", ""); // Delete all the html balises
                    return StringEscapeUtils.escapeHtml4(sanitizedPost);
                };
        return new ResponseEntity<>(
                this.getCommentsPayload(queryParams, LevelConstants.LEVEL_9, function),
                HttpStatus.OK);
    }
    //delete all the js calls
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_10,
            htmlTemplate = "LEVEL_1/PersistentXSS",
            variant = Variant.SECURE)
    public ResponseEntity<String> getSecurePayloadLevel10(
            @RequestParam Map<String, String> queryParams) {
        Function<String, String> function =
                (post) -> {
                    String sanitizedPost = StringEscapeUtils.escapeHtml4(post);
                    sanitizedPost = sanitizedPost.replaceAll("(?i)javascript:", ""); // Delete all the js calls
                    return StringEscapeUtils.escapeHtml4(sanitizedPost);
                };
        return new ResponseEntity<>(
                this.getCommentsPayload(queryParams, LevelConstants.LEVEL_10, function),
                HttpStatus.OK);
    }

}
