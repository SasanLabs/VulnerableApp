package org.sasanlabs.service.vulnerability.cryptographicFailures;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Map;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.digest.DigestUtils;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.Variant;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * Cryptographic Failures vulnerability demonstrates various issues related to weak or broken
 * cryptographic implementations. This includes: 1. Use of weak hashing algorithms (MD5, SHA1) 2.
 * Insecure cryptographic storage 3. Use of broken cryptographic algorithms (DES, RC4)
 *
 * <p>References: <br>
 * 1. https://owasp.org/Top10/A02_2021-Cryptographic_Failures/ <br>
 * 2. https://cwe.mitre.org/data/definitions/327.html <br>
 * 3. https://cwe.mitre.org/data/definitions/326.html <br>
 * 4. https://cwe.mitre.org/data/definitions/330.html <br>
 *
 * @author KSASAN preetkaran20@gmail.com
 */
@VulnerableAppRestController(
        descriptionLabel = "CRYPTOGRAPHIC_FAILURES_VULNERABILITY",
        value = "CryptographicFailures")
public class CryptographicFailuresVulnerability {

    private static final String PASSWORD_PARAM = "password";
    private static final String DATA_PARAM = "data";

    // Level 1: Using MD5 for password hashing (CWE-327)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.WEAK_CRYPTOGRAPHIC_HASH,
            description = "CRYPTOGRAPHIC_FAILURES_MD5_HASHING")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(
            @RequestParam Map<String, String> queryParams) {
        String password = queryParams.get(PASSWORD_PARAM);
        if (password == null) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Password parameter required", false),
                    HttpStatus.BAD_REQUEST);
        }

        try {
            // Vulnerable: Using MD5 which is cryptographically broken
            String hash = DigestUtils.md5Hex(password);
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "MD5 Hash: " + hash + " (VULNERABLE - MD5 is broken)", false),
                    HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Error: " + e.getMessage(), false),
                    HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // Level 2: Using SHA1 for password hashing (CWE-327)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.WEAK_CRYPTOGRAPHIC_HASH,
            description = "CRYPTOGRAPHIC_FAILURES_SHA1_HASHING")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(
            @RequestParam Map<String, String> queryParams) {
        String password = queryParams.get(PASSWORD_PARAM);
        if (password == null) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Password parameter required", false),
                    HttpStatus.BAD_REQUEST);
        }

        try {
            // Vulnerable: Using SHA1 which is deprecated and vulnerable
            String hash = DigestUtils.sha1Hex(password);
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "SHA1 Hash: " + hash + " (VULNERABLE - SHA1 is deprecated)", false),
                    HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Error: " + e.getMessage(), false),
                    HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // Level 3: Using DES encryption (CWE-330)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.USE_OF_BROKEN_CRYPTOGRAPHIC_ALGORITHM,
            description = "CRYPTOGRAPHIC_FAILURES_DES_ENCRYPTION")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(
            @RequestParam Map<String, String> queryParams) {
        String data = queryParams.get(DATA_PARAM);
        if (data == null) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Data parameter required", false),
                    HttpStatus.BAD_REQUEST);
        }

        try {
            // Vulnerable: Using DES which has 56-bit key and is cryptographically broken
            KeyGenerator keyGenerator = KeyGenerator.getInstance("DES");
            SecretKey secretKey = keyGenerator.generateKey();
            Cipher cipher = Cipher.getInstance("DES");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] encrypted = cipher.doFinal(data.getBytes());
            String encryptedBase64 = java.util.Base64.getEncoder().encodeToString(encrypted);
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "DES Encrypted: "
                                    + encryptedBase64
                                    + " (VULNERABLE - DES is broken, 56-bit key)",
                            false),
                    HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Error: " + e.getMessage(), false),
                    HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // Level 4: Storing passwords in plaintext (CWE-326)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.INSECURE_CRYPTOGRAPHIC_STORAGE,
            description = "CRYPTOGRAPHIC_FAILURES_PLAINTEXT_STORAGE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel4(
            @RequestParam Map<String, String> queryParams) {
        String password = queryParams.get(PASSWORD_PARAM);
        if (password == null) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Password parameter required", false),
                    HttpStatus.BAD_REQUEST);
        }

        // Vulnerable: Storing password in plaintext
        return new ResponseEntity<>(
                new GenericVulnerabilityResponseBean<>(
                        "Password stored as: " + password + " (VULNERABLE - Plaintext storage)", false),
                HttpStatus.OK);
    }

    // Level 5: Secure implementation using bcrypt/Argon2 (Secure)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.WEAK_CRYPTOGRAPHIC_HASH,
            description = "CRYPTOGRAPHIC_FAILURES_SECURE_BCRYPT")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            variant = Variant.SECURE,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getSecurePayloadLevel5(
            @RequestParam Map<String, String> queryParams) {
        String password = queryParams.get(PASSWORD_PARAM);
        if (password == null) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Password parameter required", false),
                    HttpStatus.BAD_REQUEST);
        }

        try {
            // Secure: Using SHA-256 with salt (in production, use bcrypt, Argon2, or PBKDF2)
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            String salt = "randomSalt123"; // In production, use secure random salt
            digest.update(salt.getBytes());
            byte[] hash = digest.digest(password.getBytes());
            String hashHex = bytesToHex(hash);
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "SHA-256 Hash (with salt): " + hashHex + " (SECURE)", true),
                    HttpStatus.OK);
        } catch (NoSuchAlgorithmException e) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Error: " + e.getMessage(), false),
                    HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // Level 6: Secure implementation using AES-256 (Secure)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.USE_OF_BROKEN_CRYPTOGRAPHIC_ALGORITHM,
            description = "CRYPTOGRAPHIC_FAILURES_SECURE_AES")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_6,
            variant = Variant.SECURE,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getSecurePayloadLevel6(
            @RequestParam Map<String, String> queryParams) {
        String data = queryParams.get(DATA_PARAM);
        if (data == null) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Data parameter required", false),
                    HttpStatus.BAD_REQUEST);
        }

        try {
            // Secure: Using AES-256 which is currently secure
            KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
            keyGenerator.init(256); // 256-bit key
            SecretKey secretKey = keyGenerator.generateKey();
            Cipher cipher = Cipher.getInstance("AES");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] encrypted = cipher.doFinal(data.getBytes());
            String encryptedBase64 = java.util.Base64.getEncoder().encodeToString(encrypted);
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "AES-256 Encrypted: " + encryptedBase64 + " (SECURE)", true),
                    HttpStatus.OK);
        } catch (Exception e) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Error: " + e.getMessage(), false),
                    HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    private String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }
}
