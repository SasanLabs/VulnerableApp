package org.sasanlabs.service.vulnerability.cryptographicFailures;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Map;
import org.apache.commons.codec.digest.DigestUtils;
import org.sasanlabs.internal.utility.LevelConstants;
import org.sasanlabs.internal.utility.Variant;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.vulnerability.bean.GenericVulnerabilityResponseBean;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * Cryptographic Failures vulnerability demonstrates various issues related to weak or broken
 * cryptographic implementations. Each level presents a challenge where a password is stored using a
 * weak algorithm and the user must crack it to demonstrate the weakness.
 *
 * <p>References: <br>
 * 1. https://owasp.org/Top10/A02_2021-Cryptographic_Failures/ <br>
 * 2. https://cwe.mitre.org/data/definitions/327.html <br>
 * 3. https://cwe.mitre.org/data/definitions/326.html <br>
 * 4. https://cwe.mitre.org/data/definitions/330.html <br>
 *
 * @author KSASAN preetkaran20@gmail.com
 */
@VulnerableAppRestController(
        descriptionLabel = "CRYPTOGRAPHIC_FAILURES_VULNERABILITY",
        value = "CryptographicFailures")
public class CryptographicFailuresVulnerability {

    private static final String PASSWORD_PARAM = "password";

    // Pre-computed secrets for each level
    private static final String LEVEL1_SECRET = "password123";
    private static final String LEVEL1_HASH = DigestUtils.md5Hex(LEVEL1_SECRET);

    private static final String LEVEL2_SECRET = "admin";
    private static final String LEVEL2_HASH = DigestUtils.sha1Hex(LEVEL2_SECRET);

    private static final String LEVEL3_SECRET = "letmein";

    private static final String LEVEL4_SECRET = "s3cretKey";
    private static final String LEVEL4_ENCODED =
            java.util.Base64.getEncoder().encodeToString(LEVEL4_SECRET.getBytes());

    private static final String LEVEL5_SECRET = "strongPass!";
    private static final String LEVEL5_SALT = "randomSalt123";
    private static final String LEVEL5_HASH;

    static {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            digest.update(LEVEL5_SALT.getBytes());
            byte[] hash = digest.digest(LEVEL5_SECRET.getBytes());
            LEVEL5_HASH = bytesToHex(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("SHA-256 not available", e);
        }
    }

    // Level 1: MD5 hash cracking challenge (CWE-327)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.WEAK_CRYPTOGRAPHIC_HASH,
            description = "CRYPTOGRAPHIC_FAILURES_MD5_HASHING")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel1(
            @RequestParam Map<String, String> queryParams) {
        String password = queryParams.get(PASSWORD_PARAM);

        // No password param: return the challenge hash
        if (password == null || password.isEmpty()) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "CHALLENGE: A user's password is stored as MD5 hash: "
                                    + LEVEL1_HASH
                                    + " — Crack it and enter the original password!",
                            false),
                    HttpStatus.OK);
        }

        // Verify the guess
        String guessHash = DigestUtils.md5Hex(password);
        if (guessHash.equals(LEVEL1_HASH)) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "Correct! The password was '"
                                    + LEVEL1_SECRET
                                    + "'. MD5 is cryptographically broken — hashes can be reversed"
                                    + " using rainbow tables and online databases.",
                            true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "Incorrect. Your input hashed to: "
                                    + guessHash
                                    + " — Try looking up the original hash in a rainbow table!",
                            false),
                    HttpStatus.OK);
        }
    }

    // Level 2: SHA1 hash cracking challenge (CWE-327)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.WEAK_CRYPTOGRAPHIC_HASH,
            description = "CRYPTOGRAPHIC_FAILURES_SHA1_HASHING")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_2,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel2(
            @RequestParam Map<String, String> queryParams) {
        String password = queryParams.get(PASSWORD_PARAM);

        if (password == null || password.isEmpty()) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "CHALLENGE: A user's password is stored as SHA1 hash: "
                                    + LEVEL2_HASH
                                    + " — Crack it and enter the original password!",
                            false),
                    HttpStatus.OK);
        }

        String guessHash = DigestUtils.sha1Hex(password);
        if (guessHash.equals(LEVEL2_HASH)) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "Correct! The password was '"
                                    + LEVEL2_SECRET
                                    + "'. SHA1 is deprecated — it is vulnerable to collision"
                                    + " attacks and hashes can be reversed using rainbow tables.",
                            true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "Incorrect. Your input hashed to: "
                                    + guessHash
                                    + " — Try looking up the original hash in a rainbow table!",
                            false),
                    HttpStatus.OK);
        }
    }

    // Level 3: Plaintext storage — password leaked in response (CWE-326)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.INSECURE_CRYPTOGRAPHIC_STORAGE,
            description = "CRYPTOGRAPHIC_FAILURES_PLAINTEXT_STORAGE")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_3,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel3(
            @RequestParam Map<String, String> queryParams) {
        String password = queryParams.get(PASSWORD_PARAM);

        if (password == null || password.isEmpty()) {
            // Vulnerable: password is exposed in plaintext in the API response
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "CHALLENGE: The system stores passwords in plaintext. "
                                    + "The stored password for user 'admin' is: "
                                    + LEVEL3_SECRET
                                    + " — Enter it below to authenticate!",
                            false),
                    HttpStatus.OK);
        }

        if (password.equals(LEVEL3_SECRET)) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "Correct! The password '"
                                    + LEVEL3_SECRET
                                    + "' was stored in plaintext with no encryption or hashing."
                                    + " Anyone with access to the storage can read it directly.",
                            true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "Incorrect. Hint: the password is visible in the challenge text above!",
                            false),
                    HttpStatus.OK);
        }
    }

    // Level 4: Base64 encoding used as "encryption" (CWE-326)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.INSECURE_CRYPTOGRAPHIC_STORAGE,
            description = "CRYPTOGRAPHIC_FAILURES_BASE64_ENCODING")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_4,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getVulnerablePayloadLevel4(
            @RequestParam Map<String, String> queryParams) {
        String password = queryParams.get(PASSWORD_PARAM);

        if (password == null || password.isEmpty()) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "CHALLENGE: The system 'encrypts' passwords using Base64 encoding. "
                                    + "The stored password is: "
                                    + LEVEL4_ENCODED
                                    + " — Decode it and enter the original password!",
                            false),
                    HttpStatus.OK);
        }

        if (password.equals(LEVEL4_SECRET)) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "Correct! The password was '"
                                    + LEVEL4_SECRET
                                    + "'. Base64 is an encoding, NOT encryption."
                                    + " It provides zero security — anyone can decode it instantly.",
                            true),
                    HttpStatus.OK);
        } else {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "Incorrect. Hint: Base64 is not encryption — try decoding '"
                                    + LEVEL4_ENCODED
                                    + "' using any Base64 decoder!",
                            false),
                    HttpStatus.OK);
        }
    }

    // Level 5: Secure — SHA-256 with salt (Secure)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.WEAK_CRYPTOGRAPHIC_HASH,
            description = "CRYPTOGRAPHIC_FAILURES_SECURE_SHA256")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_5,
            variant = Variant.SECURE,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getSecurePayloadLevel5(
            @RequestParam Map<String, String> queryParams) {
        String password = queryParams.get(PASSWORD_PARAM);

        if (password == null || password.isEmpty()) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "SECURE: This password is hashed with SHA-256 + salt. Hash: "
                                    + LEVEL5_HASH
                                    + " | Salt: "
                                    + LEVEL5_SALT
                                    + " — Try to crack it (you likely can't with rainbow tables"
                                    + " because the salt defeats pre-computed lookups).",
                            true),
                    HttpStatus.OK);
        }

        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            digest.update(LEVEL5_SALT.getBytes());
            byte[] hash = digest.digest(password.getBytes());
            String guessHash = bytesToHex(hash);

            if (guessHash.equals(LEVEL5_HASH)) {
                return new ResponseEntity<>(
                        new GenericVulnerabilityResponseBean<>(
                                "Correct! SHA-256 with salt is much more secure. In production,"
                                        + " use bcrypt, Argon2, or PBKDF2 for even stronger password"
                                        + " hashing.",
                                true),
                        HttpStatus.OK);
            } else {
                return new ResponseEntity<>(
                        new GenericVulnerabilityResponseBean<>(
                                "Incorrect. Salted hashes cannot be looked up in rainbow tables."
                                        + " This demonstrates why salting is important for password"
                                        + " security.",
                                true),
                        HttpStatus.OK);
            }
        } catch (NoSuchAlgorithmException e) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>("Error: " + e.getMessage(), false),
                    HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    // Level 6: Secure — AES-256 encryption (Secure)
    @AttackVector(
            vulnerabilityExposed = VulnerabilityType.USE_OF_BROKEN_CRYPTOGRAPHIC_ALGORITHM,
            description = "CRYPTOGRAPHIC_FAILURES_SECURE_AES")
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_6,
            variant = Variant.SECURE,
            htmlTemplate = "LEVEL_1/CryptographicFailures")
    public ResponseEntity<GenericVulnerabilityResponseBean<String>> getSecurePayloadLevel6(
            @RequestParam Map<String, String> queryParams) {
        String password = queryParams.get(PASSWORD_PARAM);

        if (password == null || password.isEmpty()) {
            return new ResponseEntity<>(
                    new GenericVulnerabilityResponseBean<>(
                            "SECURE: This system uses AES-256 encryption for data protection."
                                    + " The encryption key is never exposed to clients. Without the"
                                    + " key, the encrypted data cannot be decrypted. This is the"
                                    + " correct approach to protecting sensitive data.",
                            true),
                    HttpStatus.OK);
        }

        return new ResponseEntity<>(
                new GenericVulnerabilityResponseBean<>(
                        "AES-256 is a strong symmetric encryption algorithm. Unlike MD5/SHA1"
                                + " hashes, properly encrypted data with a secret key cannot be"
                                + " reversed without the key. This level demonstrates secure"
                                + " cryptographic practice.",
                        true),
                HttpStatus.OK);
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }
}
